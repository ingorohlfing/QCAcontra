<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Ingo Rohlfing: Filtering contradictory cases in truth tables from underyling dataframe</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h3>Ingo Rohlfing: Filtering contradictory cases in truth tables from underyling dataframe</h3>

<p><strong>Motivation behind the function</strong></p>

<p>When I worked with empirical data in QCA, I found it a little bit tedious to 
identify contradictory cases in a truth table and then look up their
set-membership values in the underlying dataset. The <code>dcc</code> option 
that Adrian Dusa built into the <code>QCA</code> package at some point simplifies
this process (see below) and is highly welcomed. Because my function
has been sitting on my hard drive for so long and the <code>dcc</code> option does
not exactly do what I want to have, I wrote a function myself and share it here.</p>

<pre><code class="r">library(QCA) # needed for illustrating QCA
library(stringr) # needed for executing the function
</code></pre>

<p>I aim creating a hypothetical dataset with contradictions in rows
that are coded as consistent for Y and as inconsistent for Y.
I directly generate fuzzy-set membership values to avoid the 
calibration stage. It works in the same way with crisp sets. </p>

<pre><code class="r">set.seed(19) # reproducibility seed
df &lt;- data.frame(A = runif(n = 20, min = 0, max = 1),
                 B = runif(n = 20, min = 0, max = 1),
                 C = runif(n = 20, min = 0, max = 1),
                 Y = runif(n = 20, min = 0, max = 1))
df &lt;- round(df, digits = 2) # rounding to shorten set-membership values
rownames(df) &lt;- LETTERS[1:nrow(df)] # assigning case IDs
</code></pre>

<p>I now create the truth table that is in its standard form not informative
about contradictions. The inclusion threshold (<code>incl.cut</code>) is chosen to create
contradictions for consistent and inconsistent rows.</p>

<pre><code class="r">dftt &lt;- truthTable(df, 
                   outcome = &quot;Y&quot;, 
                   n.cut = 1, incl.cut = 0.8,
                   show.cases = T)
</code></pre>

<pre><code class="r">dftt
</code></pre>

<pre><code>## 
##   OUT: output value
##     n: number of cases in configuration
##  incl: sufficiency inclusion score
##   PRI: proportional reduction in inconsistency
## 
##     A  B  C    OUT    n  incl  PRI   cases    
## 2   0  0  1     0     3  0.748 0.442 G,K,S    
## 3   0  1  0     1     2  0.869 0.676 B,Q      
## 4   0  1  1     0     4  0.766 0.568 A,F,L,O  
## 5   1  0  0     1     3  0.867 0.704 J,M,T    
## 7   1  1  0     0     5  0.789 0.617 C,H,I,N,P
## 8   1  1  1     0     1  0.760 0.441 R
</code></pre>

<p>The <code>QCA</code> package has a <code>dcc</code> option in the <code>truthTable()</code> command for some time
now, <code>dcc</code> standing for <em>deviant cases for consistency in kind</em>. These are members of a 
truth table row that are non-members of the outcome, which is the same as saying
it is a contradiction or contradictory case. It shows you what cases are 
contradictions by only including their case labels in the truth table.</p>

<pre><code class="r">truthTable(df, 
           outcome = &quot;Y&quot;, 
           n.cut = 1, incl.cut = 0.8,
           show.cases = T, dcc = T)
</code></pre>

<pre><code>## 
##   OUT: output value
##     n: number of cases in configuration
##  incl: sufficiency inclusion score
##   PRI: proportional reduction in inconsistency
##   DCC: deviant cases consistency
## 
##     A  B  C    OUT    n  incl  PRI   DCC
## 2   0  0  1     0     3  0.748 0.442 K,S
## 3   0  1  0     1     2  0.869 0.676 Q  
## 4   0  1  1     0     4  0.766 0.568 O  
## 5   1  0  0     1     3  0.867 0.704    
## 7   1  1  0     0     5  0.789 0.617 C,P
## 8   1  1  1     0     1  0.760 0.441 R
</code></pre>

<p>This output is informative, but in the next step you might want to lock up the cases
in the dataset and check what the membership values in the condition set and outcome
set are. One could do this by subsetting the dataset by case ID, but this can be
tedious when many cases are contradictions.</p>

<p>The function <code>tt_contra()</code> allows you to filter the dataframe for the 
contradictory cases. I am sure it could be written more efficiently, but it
serves its purpose. The ouput is a dataframe covering the contradictory
cases with their membership in the conditions and the outcome. This 
can be done for members of consistent rows and members of inconsistent rows.
The package requires loading the <code>stringr</code> package into the library.</p>

<pre><code class="r">tt_contra &lt;- function(DFname, TTname, rowtype){
  if(rowtype == 1){
    # picks case IDs from selected truth table rows (character string)
    cons_cases &lt;- TTname$tt$cases[which(TTname$tt$OUT == 1)]
    # turns character strings into a list
    cons_cases &lt;- str_split(cons_cases, &quot;,&quot;)
    # creates a character vector with one entry per case ID
    cons_cases &lt;- unlist(as.list(cons_cases))
    # filters cases from the dataframe
    dftemp &lt;- DFname[rownames(DFname) %in% cons_cases, ]
    # filters non-members of Y = contradictions by defniition
    dftemp &lt;- dftemp[dftemp$Y &lt; 0.5, ]
    # adds information about the type of row to which cases belong
    dftemp$type &lt;- &quot;consistent row&quot;
    return(dftemp)
  }
  if(rowtype == 0){
    cons_cases &lt;- TTname$tt$cases[which(TTname$tt$OUT == 0)]
    cons_cases &lt;- str_split(cons_cases, &quot;,&quot;)
    cons_cases &lt;- unlist(as.list(cons_cases))
    dftemp &lt;- DFname[rownames(DFname) %in% cons_cases, ]
    dftemp &lt;- dftemp[dftemp$Y &lt; 0.5, ]
    dftemp$type &lt;- &quot;inconsistent row&quot;
    return(dftemp)
  }
}
</code></pre>

<p>The input for the function is </p>

<ul>
<li>the name of the dataset: <code>DFname</code>,</li>
<li>the name of the truth table object: <code>TTname</code>,</li>
<li>the type of row you want: <code>1</code> for consistent rows; <code>0</code> for inconsistent
rows; <code>&quot;all&quot;</code> (or any character string) for both combined.</li>
</ul>

<p>Here is how it works with the hypothetical data and truth table.<br/>
Contradictory cases in consistent rows.</p>

<pre><code class="r">tt_contra(df, dftt, rowtype = 1)
</code></pre>

<pre><code>##     A    B    C    Y           type
## Q 0.4 0.69 0.07 0.28 consistent row
</code></pre>

<p>Contradictory cases in inconsistent rows.</p>

<pre><code class="r">tt_contra(df, dftt, rowtype = 0)
</code></pre>

<pre><code>##      A    B    C    Y             type
## C 0.65 0.81 0.15 0.35 inconsistent row
## K 0.41 0.40 0.70 0.03 inconsistent row
## O 0.23 0.92 0.98 0.01 inconsistent row
## P 0.90 0.79 0.13 0.09 inconsistent row
## R 0.57 0.70 0.88 0.09 inconsistent row
## S 0.43 0.24 0.60 0.17 inconsistent row
</code></pre>

<p><a href="./QCAcontra.R">R script</a> and <a href="./QCAcontra.md">Markdown file</a> for this analysis.</p>

<p><strong>Parameters of analysis</strong></p>

<pre><code class="r">devtools::session_info()
</code></pre>

<pre><code>## - Session info -------------------------------------------------------------------------------------------------------------------
##  setting  value                       
##  version  R version 3.5.3 (2019-03-11)
##  os       Windows 10 x64              
##  system   x86_64, mingw32             
##  ui       RStudio                     
##  language (EN)                        
##  collate  German_Germany.1252         
##  ctype    German_Germany.1252         
##  tz       Europe/Berlin               
##  date     2019-12-21                  
## 
## - Packages -----------------------------------------------------------------------------------------------------------------------
##  package     * version date       lib source        
##  admisc      * 0.5     2019-11-03 [1] CRAN (R 3.5.3)
##  assertthat    0.2.1   2019-03-21 [1] CRAN (R 3.5.3)
##  backports     1.1.5   2019-10-02 [1] CRAN (R 3.5.3)
##  callr         3.4.0   2019-12-09 [1] CRAN (R 3.5.3)
##  cli           2.0.0   2019-12-09 [1] CRAN (R 3.5.3)
##  crayon        1.3.4   2017-09-16 [1] CRAN (R 3.5.1)
##  desc          1.2.0   2018-05-01 [1] CRAN (R 3.5.1)
##  devtools      2.2.1   2019-09-24 [1] CRAN (R 3.5.3)
##  digest        0.6.23  2019-11-23 [1] CRAN (R 3.5.3)
##  ellipsis      0.3.0   2019-09-20 [1] CRAN (R 3.5.3)
##  evaluate      0.14    2019-05-28 [1] CRAN (R 3.5.3)
##  fansi         0.4.0   2018-10-05 [1] CRAN (R 3.5.1)
##  fastmap       1.0.1   2019-10-08 [1] CRAN (R 3.5.3)
##  fs            1.3.1   2019-05-06 [1] CRAN (R 3.5.3)
##  glue          1.3.1   2019-03-12 [1] CRAN (R 3.5.3)
##  highr         0.8     2019-03-20 [1] CRAN (R 3.5.3)
##  htmltools     0.4.0   2019-10-04 [1] CRAN (R 3.5.3)
##  httpuv        1.5.2   2019-09-11 [1] CRAN (R 3.5.3)
##  knitr       * 1.26    2019-11-12 [1] CRAN (R 3.5.3)
##  later         1.0.0   2019-10-04 [1] CRAN (R 3.5.3)
##  magrittr      1.5     2014-11-22 [1] CRAN (R 3.5.1)
##  memoise       1.1.0   2017-04-21 [1] CRAN (R 3.5.1)
##  mime          0.7     2019-06-11 [1] CRAN (R 3.5.3)
##  pkgbuild      1.0.6   2019-10-09 [1] CRAN (R 3.5.3)
##  pkgload       1.0.2   2018-10-29 [1] CRAN (R 3.5.1)
##  prettyunits   1.0.2   2015-07-13 [1] CRAN (R 3.5.1)
##  processx      3.4.1   2019-07-18 [1] CRAN (R 3.5.3)
##  promises      1.1.0   2019-10-04 [1] CRAN (R 3.5.3)
##  ps            1.3.0   2018-12-21 [1] CRAN (R 3.5.2)
##  QCA         * 3.6     2019-11-17 [1] CRAN (R 3.5.3)
##  R6            2.4.1   2019-11-12 [1] CRAN (R 3.5.3)
##  Rcpp          1.0.2   2019-07-25 [1] CRAN (R 3.5.3)
##  remotes       2.1.0   2019-06-24 [1] CRAN (R 3.5.3)
##  rlang         0.4.1   2019-10-24 [1] CRAN (R 3.5.3)
##  rprojroot     1.3-2   2018-01-03 [1] CRAN (R 3.5.1)
##  sessioninfo   1.1.1   2018-11-05 [1] CRAN (R 3.5.1)
##  shiny         1.4.0   2019-10-10 [1] CRAN (R 3.5.3)
##  stringi       1.4.3   2019-03-12 [1] CRAN (R 3.5.3)
##  stringr     * 1.4.0   2019-02-10 [1] CRAN (R 3.5.2)
##  testthat      2.3.1   2019-12-01 [1] CRAN (R 3.5.3)
##  usethis       1.5.1   2019-07-04 [1] CRAN (R 3.5.3)
##  venn          1.7     2018-07-31 [1] CRAN (R 3.5.1)
##  withr         2.1.2   2018-03-15 [1] CRAN (R 3.5.1)
##  xfun          0.10    2019-10-01 [1] CRAN (R 3.5.3)
##  xtable        1.8-4   2019-04-21 [1] CRAN (R 3.5.3)
## 
## [1] C:/Users/Ingo R/Documents/R/win-library/3.5
## [2] C:/Program Files/R/R-3.5.3/library
</code></pre>

<p>Packages used for analysis.</p>

<ul>
<li>  base (R Core Team 2019)</li>
<li>  grateful (Rodriguez-Sanchez 2018)</li>
<li>  stringr (Wickham 2019)</li>
<li>  QCA (Dusa 2019b)</li>
<li>  admisc (Dusa 2019a)</li>
</ul>

<h2>References</h2>

<p>Dusa, Adrian. 2019a. <em>admisc: Adrian Dusa&#39;s Miscellaneous</em>.<br/>
 <a href="https://CRAN.R-project.org/package=admisc">https://CRAN.R-project.org/package=admisc</a>.</p>

<p>&mdash;. 2019b. <em>QCA with R. A Comprehensive Resource</em>. Cham, Switzerland:<br/>
 Springer International Publishing.</p>

<p>R Core Team. 2019. <em>R: A Language and Environment for Statistical Computing</em>.<br/>
 Vienna, Austria: R Foundation for Statistical Computing.<br/>
 <a href="https://www.R-project.org/">https://www.R-project.org/</a>.</p>

<p>Rodriguez-Sanchez, Francisco. 2018. <em>grateful: Facilitate Citation of R Packages</em>.<br/>
 <a href="https://github.com/Pakillo/grateful">https://github.com/Pakillo/grateful</a>.</p>

<p>Wickham, Hadley. 2019. <em>stringr: Simple, Consistent Wrappers for Common String Operations</em>.<br/>
 <a href="https://CRAN.R-project.org/package=stringr">https://CRAN.R-project.org/package=stringr</a>.</p>

</body>

</html>
